"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const tsutils = require("tsutils/typeguard/3.0");
exports.objectIdentifier = ts.createIdentifier('object');
exports.pathIdentifier = ts.createIdentifier('path');
const keyIdentifier = ts.createIdentifier('key');
function checkIsClass(type, visitorContext) {
    // Hacky: using internal TypeScript API.
    if ('isArrayType' in visitorContext.checker && visitorContext.checker.isArrayType(type)) {
        return false;
    }
    if ('isArrayLikeType' in visitorContext.checker && visitorContext.checker.isArrayLikeType(type)) {
        return false;
    }
    let hasConstructSignatures = false;
    if (type.symbol !== undefined && type.symbol.valueDeclaration !== undefined && ts.isVariableDeclaration(type.symbol.valueDeclaration) && type.symbol.valueDeclaration.type) {
        const variableDeclarationType = visitorContext.checker.getTypeAtLocation(type.symbol.valueDeclaration.type);
        const constructSignatures = variableDeclarationType.getConstructSignatures();
        hasConstructSignatures = constructSignatures.length >= 1;
    }
    if (type.isClass() || hasConstructSignatures) {
        if (visitorContext.options.ignoreClasses) {
            return true;
        }
        else {
            throw new Error('Classes cannot be validated. https://github.com/woutervh-/typescript-is/issues/3');
        }
    }
    else {
        return false;
    }
}
exports.checkIsClass = checkIsClass;
function setFunctionIfNotExists(name, visitorContext, factory) {
    if (!visitorContext.functionNames.has(name)) {
        visitorContext.functionNames.add(name);
        visitorContext.functionMap.set(name, factory());
    }
    return name;
}
exports.setFunctionIfNotExists = setFunctionIfNotExists;
function getPropertyInfo(symbol, visitorContext) {
    const name = symbol.name;
    if (name === undefined) {
        throw new Error('Missing name in property symbol.');
    }
    if ('valueDeclaration' in symbol) {
        const valueDeclaration = symbol.valueDeclaration;
        if (!ts.isPropertySignature(valueDeclaration) && !ts.isMethodSignature(valueDeclaration)) {
            throw new Error('Unsupported declaration kind: ' + valueDeclaration.kind);
        }
        const isMethod = ts.isMethodSignature(valueDeclaration);
        const isFunction = valueDeclaration.type !== undefined && ts.isFunctionTypeNode(valueDeclaration.type);
        if (isMethod && !visitorContext.options.ignoreMethods) {
            throw new Error('Encountered a method declaration, but methods are not supported. Issue: https://github.com/woutervh-/typescript-is/issues/5');
        }
        if (isFunction && !visitorContext.options.ignoreFunctions) {
            throw new Error('Encountered a function declaration, but functions are not supported. Issue: https://github.com/woutervh-/typescript-is/issues/50');
        }
        let propertyType = undefined;
        if (valueDeclaration.type === undefined) {
            if (!isMethod) {
                throw new Error('Found property without type.');
            }
        }
        else {
            propertyType = visitorContext.checker.getTypeFromTypeNode(valueDeclaration.type);
        }
        return {
            name,
            type: propertyType,
            isMethod,
            isSymbol: name.startsWith('__@'),
            optional: !!valueDeclaration.questionToken
        };
    }
    else {
        const propertyType = symbol.type;
        const optional = (symbol.flags & ts.SymbolFlags.Optional) !== 0;
        if (propertyType !== undefined) {
            return {
                name,
                type: propertyType,
                isMethod: false,
                isSymbol: name.startsWith('__@'),
                optional
            };
        }
        else {
            throw new Error('Expected a valueDeclaration or a property type.');
        }
    }
}
exports.getPropertyInfo = getPropertyInfo;
function getTypeReferenceMapping(type, visitorContext) {
    const mapping = new Map();
    (function checkBaseTypes(type) {
        if (tsutils.isInterfaceType(type.target)) {
            const baseTypes = visitorContext.checker.getBaseTypes(type.target);
            for (const baseType of baseTypes) {
                if (tsutils.isTypeReference(baseType) && baseType.target.typeParameters !== undefined && baseType.typeArguments !== undefined) {
                    const typeParameters = baseType.target.typeParameters;
                    const typeArguments = baseType.typeArguments;
                    for (let i = 0; i < typeParameters.length; i++) {
                        if (typeParameters[i] !== typeArguments[i]) {
                            mapping.set(typeParameters[i], typeArguments[i]);
                        }
                    }
                    checkBaseTypes(baseType);
                }
            }
        }
    })(type);
    if (type.target.typeParameters !== undefined && type.typeArguments !== undefined) {
        const typeParameters = type.target.typeParameters;
        const typeArguments = type.typeArguments;
        for (let i = 0; i < typeParameters.length; i++) {
            if (typeParameters[i] !== typeArguments[i]) {
                mapping.set(typeParameters[i], typeArguments[i]);
            }
        }
    }
    return mapping;
}
exports.getTypeReferenceMapping = getTypeReferenceMapping;
function getResolvedTypeParameter(type, visitorContext) {
    let mappedType;
    for (let i = visitorContext.typeMapperStack.length - 1; i >= 0; i--) {
        mappedType = visitorContext.typeMapperStack[i].get(type);
        if (mappedType !== undefined) {
            break;
        }
    }
    return mappedType || type.getDefault();
}
exports.getResolvedTypeParameter = getResolvedTypeParameter;
function getStringFunction(visitorContext) {
    const name = '_string';
    return setFunctionIfNotExists(name, visitorContext, () => {
        return createAssertionFunction(ts.createStrictInequality(ts.createTypeOf(exports.objectIdentifier), ts.createStringLiteral('string')), { type: 'string' }, name, createStrictNullCheckStatement(exports.objectIdentifier, visitorContext));
    });
}
exports.getStringFunction = getStringFunction;
function getBooleanFunction(visitorContext) {
    const name = '_boolean';
    return setFunctionIfNotExists(name, visitorContext, () => {
        return createAssertionFunction(ts.createStrictInequality(ts.createTypeOf(exports.objectIdentifier), ts.createStringLiteral('boolean')), { type: 'boolean' }, name, createStrictNullCheckStatement(exports.objectIdentifier, visitorContext));
    });
}
exports.getBooleanFunction = getBooleanFunction;
function getBigIntFunction(visitorContext) {
    const name = '_bigint';
    return setFunctionIfNotExists(name, visitorContext, () => {
        return createAssertionFunction(ts.createStrictInequality(ts.createTypeOf(exports.objectIdentifier), ts.createStringLiteral('bigint')), { type: 'big-int' }, name, createStrictNullCheckStatement(exports.objectIdentifier, visitorContext));
    });
}
exports.getBigIntFunction = getBigIntFunction;
function getNumberFunction(visitorContext) {
    const name = '_number';
    return setFunctionIfNotExists(name, visitorContext, () => {
        return createAssertionFunction(ts.createStrictInequality(ts.createTypeOf(exports.objectIdentifier), ts.createStringLiteral('number')), { type: 'number' }, name, createStrictNullCheckStatement(exports.objectIdentifier, visitorContext));
    });
}
exports.getNumberFunction = getNumberFunction;
function getUndefinedFunction(visitorContext) {
    const name = '_undefined';
    return setFunctionIfNotExists(name, visitorContext, () => {
        return createAssertionFunction(ts.createStrictInequality(exports.objectIdentifier, ts.createIdentifier('undefined')), { type: 'undefined' }, name, createStrictNullCheckStatement(exports.objectIdentifier, visitorContext));
    });
}
exports.getUndefinedFunction = getUndefinedFunction;
function getNullFunction(visitorContext) {
    const name = '_null';
    return setFunctionIfNotExists(name, visitorContext, () => {
        return createAssertionFunction(ts.createStrictInequality(exports.objectIdentifier, ts.createNull()), { type: 'null' }, name, createStrictNullCheckStatement(exports.objectIdentifier, visitorContext));
    });
}
exports.getNullFunction = getNullFunction;
function getNeverFunction(visitorContext) {
    const name = '_never';
    return setFunctionIfNotExists(name, visitorContext, () => {
        return ts.createFunctionDeclaration(undefined, undefined, undefined, name, undefined, [
            ts.createParameter(undefined, undefined, undefined, exports.objectIdentifier, undefined, undefined, undefined)
        ], undefined, ts.createBlock([
            ts.createReturn(createErrorObject({ type: 'never' }))
        ]));
    });
}
exports.getNeverFunction = getNeverFunction;
function getUnknownFunction(visitorContext) {
    const name = '_unknown';
    return setFunctionIfNotExists(name, visitorContext, () => {
        return createAcceptingFunction(name);
    });
}
exports.getUnknownFunction = getUnknownFunction;
function getAnyFunction(visitorContext) {
    const name = '_any';
    return setFunctionIfNotExists(name, visitorContext, () => {
        return createAcceptingFunction(name);
    });
}
exports.getAnyFunction = getAnyFunction;
function getIgnoredTypeFunction(visitorContext) {
    const name = '_ignore';
    return setFunctionIfNotExists(name, visitorContext, () => {
        return createAcceptingFunction(name);
    });
}
exports.getIgnoredTypeFunction = getIgnoredTypeFunction;
function createBinaries(expressions, operator, baseExpression) {
    if (expressions.length >= 1 || baseExpression === undefined) {
        return expressions.reduce((previous, expression) => ts.createBinary(previous, operator, expression));
    }
    else {
        return baseExpression;
    }
}
exports.createBinaries = createBinaries;
function createAcceptingFunction(functionName) {
    return ts.createFunctionDeclaration(undefined, undefined, undefined, functionName, undefined, [], undefined, ts.createBlock([ts.createReturn(ts.createNull())]));
}
exports.createAcceptingFunction = createAcceptingFunction;
function createConjunctionFunction(functionNames, functionName, extraStatements) {
    const conditionsIdentifier = ts.createIdentifier('conditions');
    const conditionIdentifier = ts.createIdentifier('condition');
    const errorIdentifier = ts.createIdentifier('error');
    return ts.createFunctionDeclaration(undefined, undefined, undefined, functionName, undefined, [
        ts.createParameter(undefined, undefined, undefined, exports.objectIdentifier, undefined, undefined, undefined)
    ], undefined, ts.createBlock([
        ts.createVariableStatement([ts.createModifier(ts.SyntaxKind.ConstKeyword)], [
            ts.createVariableDeclaration(conditionsIdentifier, undefined, ts.createArrayLiteral(functionNames.map((functionName) => ts.createIdentifier(functionName))))
        ]),
        ts.createForOf(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(conditionIdentifier, undefined, undefined)], ts.NodeFlags.Const), conditionsIdentifier, ts.createBlock([
            ts.createVariableStatement([ts.createModifier(ts.SyntaxKind.ConstKeyword)], [
                ts.createVariableDeclaration(errorIdentifier, undefined, ts.createCall(conditionIdentifier, undefined, [exports.objectIdentifier]))
            ]),
            ts.createIf(errorIdentifier, ts.createReturn(errorIdentifier))
        ])),
        ...(extraStatements || []),
        ts.createReturn(ts.createNull())
    ]));
}
exports.createConjunctionFunction = createConjunctionFunction;
function createDisjunctionFunction(functionNames, functionName) {
    const conditionsIdentifier = ts.createIdentifier('conditions');
    const conditionIdentifier = ts.createIdentifier('condition');
    const errorIdentifier = ts.createIdentifier('error');
    return ts.createFunctionDeclaration(undefined, undefined, undefined, functionName, undefined, [
        ts.createParameter(undefined, undefined, undefined, exports.objectIdentifier, undefined, undefined, undefined)
    ], undefined, ts.createBlock([
        ts.createVariableStatement([ts.createModifier(ts.SyntaxKind.ConstKeyword)], [
            ts.createVariableDeclaration(conditionsIdentifier, undefined, ts.createArrayLiteral(functionNames.map((functionName) => ts.createIdentifier(functionName))))
        ]),
        ts.createForOf(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(conditionIdentifier, undefined, undefined)], ts.NodeFlags.Const), conditionsIdentifier, ts.createBlock([
            ts.createVariableStatement([ts.createModifier(ts.SyntaxKind.ConstKeyword)], [
                ts.createVariableDeclaration(errorIdentifier, undefined, ts.createCall(conditionIdentifier, undefined, [exports.objectIdentifier]))
            ]),
            ts.createIf(ts.createLogicalNot(errorIdentifier), ts.createReturn(ts.createNull()))
        ])),
        ts.createReturn(createErrorObject({ type: 'union' }))
    ]));
}
exports.createDisjunctionFunction = createDisjunctionFunction;
function createStrictNullCheckStatement(identifier, visitorContext) {
    if (visitorContext.compilerOptions.strictNullChecks !== false) {
        return ts.createEmptyStatement();
    }
    else {
        return ts.createIf(ts.createBinary(ts.createStrictEquality(identifier, ts.createNull()), ts.SyntaxKind.BarBarToken, ts.createStrictEquality(identifier, ts.createIdentifier('undefined'))), ts.createReturn(ts.createNull()));
    }
}
exports.createStrictNullCheckStatement = createStrictNullCheckStatement;
function createAssertionFunction(failureCondition, expected, functionName, ...otherStatements) {
    return ts.createFunctionDeclaration(undefined, undefined, undefined, functionName, undefined, [
        ts.createParameter(undefined, undefined, undefined, exports.objectIdentifier, undefined, undefined, undefined)
    ], undefined, ts.createBlock([
        ...otherStatements,
        ts.createIf(failureCondition, ts.createReturn(createErrorObject(expected)), ts.createReturn(ts.createNull()))
    ]));
}
exports.createAssertionFunction = createAssertionFunction;
function createSuperfluousPropertiesLoop(propertyNames) {
    return ts.createForOf(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(keyIdentifier, undefined, undefined)], ts.NodeFlags.Const), ts.createCall(ts.createPropertyAccess(ts.createIdentifier('Object'), 'keys'), undefined, [exports.objectIdentifier]), ts.createBlock([
        ts.createIf(createBinaries(propertyNames.map((propertyName) => ts.createStrictInequality(keyIdentifier, ts.createStringLiteral(propertyName))), ts.SyntaxKind.AmpersandAmpersandToken, ts.createTrue()), ts.createReturn(createErrorObject({ type: 'superfluous-property' })))
    ]));
}
exports.createSuperfluousPropertiesLoop = createSuperfluousPropertiesLoop;
function isBigIntType(type) {
    if ('BigInt' in ts.TypeFlags) {
        return ts.TypeFlags.BigInt & type.flags;
    }
    else {
        return false;
    }
}
exports.isBigIntType = isBigIntType;
function createAssertionString(reason) {
    if (typeof reason === 'string') {
        return createBinaries([
            ts.createStringLiteral('validation failed at '),
            ts.createCall(ts.createPropertyAccess(exports.pathIdentifier, 'join'), undefined, [ts.createStringLiteral('.')]),
            ts.createStringLiteral(`: ${reason}`)
        ], ts.SyntaxKind.PlusToken);
    }
    else {
        return createBinaries([
            ts.createStringLiteral('validation failed at '),
            ts.createCall(ts.createPropertyAccess(exports.pathIdentifier, 'join'), undefined, [ts.createStringLiteral('.')]),
            ts.createStringLiteral(`: `),
            reason
        ], ts.SyntaxKind.PlusToken);
    }
}
function createErrorObject(reason) {
    return ts.createObjectLiteral([
        ts.createPropertyAssignment('message', createErrorMessage(reason)),
        ts.createPropertyAssignment('path', ts.createCall(ts.createPropertyAccess(exports.pathIdentifier, 'slice'), undefined, undefined)),
        ts.createPropertyAssignment('reason', serializeObjectToExpression(reason))
    ]);
}
exports.createErrorObject = createErrorObject;
function serializeObjectToExpression(object) {
    if (typeof object === 'string') {
        return ts.createStringLiteral(object);
    }
    else if (typeof object === 'number') {
        return ts.createNumericLiteral(object.toString());
    }
    else if (typeof object === 'boolean') {
        return object ? ts.createTrue() : ts.createFalse();
    }
    else if (typeof object === 'bigint') {
        return ts.createBigIntLiteral(object.toString());
    }
    else if (typeof object === 'undefined') {
        return ts.createIdentifier('undefined');
    }
    else if (typeof object === 'object') {
        if (object === null) {
            return ts.createNull();
        }
        else if (Array.isArray(object)) {
            return ts.createArrayLiteral(object.map((item) => serializeObjectToExpression(item)));
        }
        else {
            return ts.createObjectLiteral(Object.keys(object).map((key) => {
                const value = object[key];
                return ts.createPropertyAssignment(key, serializeObjectToExpression(value));
            }));
        }
    }
    throw new Error('Cannot serialize object to expression.');
}
function createErrorMessage(reason) {
    switch (reason.type) {
        case 'tuple':
            return createAssertionString(`expected an array with length ${reason.minLength}-${reason.maxLength}`);
        case 'array':
            return createAssertionString('expected an array');
        case 'object':
            return createAssertionString('expected an object');
        case 'missing-property':
            return createAssertionString(`expected '${reason.property}' in object`);
        case 'superfluous-property':
            return createAssertionString(createBinaries([
                ts.createStringLiteral(`superfluous property '`),
                keyIdentifier,
                ts.createStringLiteral(`' in object`)
            ], ts.SyntaxKind.PlusToken));
        case 'never':
            return createAssertionString('type is never');
        case 'union':
            return createAssertionString('there are no valid alternatives');
        case 'string':
            return createAssertionString('expected a string');
        case 'boolean':
            return createAssertionString('expected a boolean');
        case 'big-int':
            return createAssertionString('expected a bigint');
        case 'number':
            return createAssertionString('expected a number');
        case 'undefined':
            return createAssertionString('expected undefined');
        case 'null':
            return createAssertionString('expected null');
        case 'object-keyof':
            return createAssertionString(`expected ${reason.properties.map((property) => `'${property}'`).join('|')}`);
        case 'string-literal':
            return createAssertionString(`expected string '${reason.value}'`);
        case 'number-literal':
            return createAssertionString(`expected number '${reason.value}'`);
        case 'boolean-literal':
            return createAssertionString(`expected ${reason.value ? 'true' : 'false'}`);
        case 'non-primitive':
            return createAssertionString('expected a non-primitive');
    }
}
//# sourceMappingURL=visitor-utils.js.map